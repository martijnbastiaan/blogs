# Tricking Haskell into state: how Clash's `Signal` type works
I recently came across a [question on /r/haskell](https://old.reddit.com/r/haskell/comments/1hjyzfv/can_clashhaskellsupport_for_asynchronous_circuit/), where [/u/netj_nsh](https://old.reddit.com/user/netj_nsh) asked whether Clash supports asynchronous circuit designs. They went on to ask whether designing with multiple, synchronous clock domains is possible. While the (very) short answers are _no_ and _yes_, respectively, I figured I'd write a blog post clarifying these concepts and how they relate to Clash. Mostly though, I just wanted an excuse to write about Clash's simple yet clever trick that makes it tick: `Signal`.

## Combinational logic
In digital design, [combinational logic](https://en.wikipedia.org/wiki/Combinational_logic) is a type of logic circuit that has no memory. It's a circuit that computes its output based solely on its inputs. This is very similar to the concept of a pure function in functional programming: a function that always produces the same output for the same input, with no side effects. For any function in Haskell we therefore know that we can translate it to a digital design if:

1. The function is pure: it has no side effects. In Haskell this is enforced by the type system: the absence of `IO` in its type signature indicates it is pure<sup>1</sup>.
2. All arguments and the return value are of a type that can be represented as a finite number of bits.
3. Any recursion, if present, should terminate at compile time. I.e., no data dependent recursion.

<!-- This doesn't mean we cannot _use_ functions that are non-representable on their own though. Take `map`:

```haskell
map ::
  (a -> b) -> -- argument 1: a function from type `a` to type `b`
  Vec n a ->  -- argument 2: a vector of `n` elements with element type `a`
  Vec n b     -- result:     a vector of `n` elements with element type `b`
```

`map` is a higher-order function that applies a function to each element of a vector. The function `a -> b` is not representable as a finite number of bits<sup>2</sup>, but we can still use `map` in our designs. For example, `map (+1)` is a function that adds one to each element of a vector. This function is representable in hardware:

```haskell
top :: Vec 3 Int -> Vec 3 Int
top vec = map (+1) vec
```

Clash will inline the definition of `map` to obtain a structure that's more obviously representable in hardware:

```haskell
top :: Vec 3 Int -> Vec 3 Int
top (e1 :> e2 :> e3 :> Nil) = (e1 + 1) :> (e2 + 1) :> (e3 + 1) :> Nil
``` -->

Because Haskell is an excellent language to describe pure functions (subjective, I know), it should also be an excellent language to describe combinatorial logic. This leaves a big chunk of hardware designs though: most realistic designs have lots of local state. In fact, local state is often the only way to [reach realistic clock speeds](https://en.wikipedia.org/wiki/Pipelining_(DSP_implementation)). To have any shot at becoming a good hardware description language, Clash should therefore be able to describe non-combinational (_sequential_) logic too. Still, you won't find the typical way of keeping state (e.g., the `State` monad) in a typical Clash design.

## The digital, sequential abstraction
Digital hardware designs introduce state through memory elements called *flip-flop*s. These elements take a clock signal and a data signal. At clock edge they're sensitive to, they *latch* the signal on their data input (**D**) and propagate it to their output (**Q**). Though composed of more elemental components, they are often represented as a single box:

![A basic flip-flop diagram with a clock input, a data input (D), and a data output (Q)](flipflop.drawio.png)

To reliably capture data, the incoming signal should be stable both before and after the active clock edge. These periods are called the [*setup* and *hold* time](https://www.icdesigntips.com/2020/10/setup-and-hold-time-explained.html) and can vary wildly per [fabrication process](https://en.wikipedia.org/wiki/Semiconductor_device_fabrication). The following picture marks the "unstable" period with Xs --- data is allowed to change in this region and indicates the maximum [propagation delay](https://en.wikipedia.org/wiki/Propagation_delay) for the signal.

![alt text](setup-hold-1.drawio.png)

If we chain these together and mark the stable periods with a label, we get the following picture:

![alt text](setup-hold-2.drawio.png)


This is very close to how digital designers think: they think in terms of *stable periods*. Hence, an often heard phrase is: *at clock tick **x**, the value of the signal was **y***. Condensing the previous diagram to its essentials, we get a [waveform](https://en.wikipedia.org/wiki/Waveform) diagram (in this case generated by [wavedrom](https://wavedrom.com/editor.html)):

![alt text](wavedrom1.png)

This abstraction is called the digital, sequential abstraction. Digital, because we don't consider any signal levels between 0 or 1. Sequential, because flip-flops can introduce memory/state.

## Signals
Using the digital, sequential abraction signals over time can be modelled as linked lists. Each element represents the stable value at each clock tick. The default list (`[]`) implementation in Haskell already gets us pretty close:

```haskell
data List a
  = []
  | a : List a
```

This allows us to write:

```haskell
>>> 1 : 2 : 3 : 4 : []
[1, 2, 3, 4]
>>> [1, 2, 3, 4] -- syntax sugar
[1, 2, 3, 4]
```

This is very close to what we want from a signal, but we're missing two things:

* Signals don't really have an "end"
* Signals have a clock domain associated with them

Hence, if we look at the definition of Clash's `Signal` we see:

```haskell
data Signal (dom :: Domain) (a :: Type) = a :- Signal dom a
```

We can use this definition in simulation:

```haskell
>>> signal = pure 1 :: Signal System Int
>>> signal
1 :- 1 :- 1 :- 1 :- 1 :-
^C
```

To save some time, I pressed interrupt (`^C`) to prevent Haskell from printing indefinitely. Like lists, we can map over it:

```haskell
>>> fmap (+10) signal -- More typically written as `+10 <$> signal`
11 :- 11 :- 11 :- 11 :- 11 :-
^C
```

We can also combine multiple signals and perform some computation on them<sup>2</sup>:

```haskell
>>> liftA2 (+) signal signal -- More typically written as `(+) <$> signal <*> signal`
2 :- 2 :- 2 :- 2 :- 2 :-
^C
```

As discussed in the _combinational logic_ section, Clash shouldn't be able to translate the definitions of `fmap` and `liftA2`: after all, they act on infinitely recurring data types! In practice it can, because these operations are marked as _primitive_: Clash will inject a hardcoded bit of HDL any time it sees these operations.

## Signals 🤝 state
So far we've only seen combinational operations: we haven't introduced any state yet. Worse, with the introduced primitives we cannot add state any either. Let's take a step back and see what it would have to look like:

![alt text](wavedrom2.png)

I.e., the output signal **Q** is a shifted version of **D**. In this diagram, the initial state of the register is [undefined](https://clash-lang.org/blog/0004-undefined-values/). A fourth primitive Clash offers is therefore `register`:

```haskell
-- | Simplified version of Clash's `register`: the actual version has more control signals.
register :: Clock dom -> Signal dom a -> Signal dom a
register _clk signal = undefined :- signal
```

Again, when Clash sees this primitive used, it injects a hardcoded bit of HDL. And just like that, we've introduced state. We can now implement a simple counter:

```haskell
counter = register clock (fmap (+1) counter)

-- Because `Signal` has a `Num` instance, we can also write:
-- counter = register clock (counter + 1)
```

## Signals on multiple domains
One of the questions `/u/netj_nsh` asked was: 

> Does Clash [..] support [..] synchronous design with clock domain crossing?

With the pritmivies introduced we cannot construct any CDC.  In fact, the Haskell compiler will stop us before we even get a chance to run it:

```haskell
>>> a = pure 3 :: Signal A Int
>>> b = pure 5 :: Signal B Int
>>> liftA2 (+) a b
*** Type error: could not deduce A ~ B
```

And this is great! It means you can never accidentally cross clock domains in Clash. Of course, sometimes you *do* want to cross clock domains, which can be done with yet another primitive: `unsafeSynchronizer`:

```haskell
unsafeSynchronizer :: Clock dom1 -> Clock dom2 -> Signal dom1 a -> Signal dom2 a
```

By extracting 

![alt text](wavedrom3.png)

TODO: Implement unsafesyncer in JavaScript and make interactive using wavedrom

## Signals: a leaky abstraction
A => B => C, loss of info!

![alt text](wavedrom4.png)


## Recap
To recap, `Signal` works because its implementation is hidden from the public API. To make the data type usefull still, primitives are offered:

* `pure`: construct a signal
* `<$>` or `fmapSignal`: apply a pure function/combinational circuit to a signal
* `<*>` or `appSignal`: merge multiple signals on the same domain
* `register`: introduce state

Multiple domains are "synchronized" by calculating relative offsets between the clocks on each domain and constructing a new signal.


<!-- ```wavedrom
{ signal: [
  { name: "pclk", wave: 'p....' },
  { name: "D",    wave: "22222",  data: ["A", "B", "C", "D", "E"] },
  { name: "Q",    wave: "x2222",  data: ["A", "B", "C", "D", "E"] },
]}
``` -->

## TODO
* Mention dynamic clock domains
* Clarify Haskell vs Clash
* Try in REPL / copy paste errors+returns
* Port to clash-lang.org
* Port to qbaylogic.com

## Footnotes
<sup>1</sup>This isn't entirely true: Haskell provides "escape hatches" such as `unsafePerformIO` that allow you to break purity.

<!-- <sup>2</sup>In theory Clash could analyze `map`, determine how often it uses its function argument, and render that as input and outputs. At the time of writing, Clash does not do this. -->

<sup>2</sup>These three operations effectively implement `Applicative` (and `Functor`).
